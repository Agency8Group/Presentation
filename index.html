<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>브랜드 슬라이드쇼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script
        src="https://unpkg.com/@lottiefiles/dotlottie-wc@0.8.1/dist/dotlottie-wc.js"
        type="module"
    ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
        
        html {
            width: 100%;
            height: 100%;
        }
        
        .slideshow-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-width: 100vw;
            min-height: 100vh;
            background: #000;
            margin: 0;
            padding: 0;
        }
        
        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-width: 100vw;
            min-height: 100vh;
            opacity: 0;
            transform: scale(1.05);
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .slide.active {
            opacity: 1;
            transform: scale(1);
        }
        
        .slide-image {
            width: 100%;
            height: 100%;
            min-width: 100vw;
            min-height: 100vh;
            object-fit: cover;
            object-position: center;
            display: block;
        }
        
        .slide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-width: 100vw;
            min-height: 100vh;
            background: linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.4) 0%,
                rgba(0, 0, 0, 0.2) 30%,
                rgba(0, 0, 0, 0.1) 50%,
                rgba(0, 0, 0, 0.3) 70%,
                rgba(0, 0, 0, 0.6) 100%
            );
        }
        
        .slide-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 10;
            width: 90%;
            max-width: 800px;
        }
        
        .slide-title {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            line-height: 1.1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.1));
            padding: 0.5rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(2px);
        }
        
        .slide-title.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .slide-subtitle {
            font-size: 1.5rem;
            font-weight: 300;
            opacity: 0;
            transform: translateY(20px);
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            transition-delay: 0.3s;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            padding: 0.3rem 0.8rem;
            border-radius: 6px;
            backdrop-filter: blur(1px);
        }
        
        .slide-subtitle.show {
            opacity: 0.9;
            transform: translateY(0);
        }
        
        .final-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-width: 100vw;
            min-height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: translateY(50px) scale(0.95);
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* 파티클 컨테이너 */
        .particles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-width: 100vw;
            min-height: 100vh;
            pointer-events: none;
            z-index: 1;
        }
        
        .final-screen.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .final-content {
            text-align: center;
            color: white;
        }
        
        .final-title {
            font-size: 6rem;
            font-weight: 700;
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            padding: 1rem 2rem;
            border-radius: 12px;
            backdrop-filter: blur(3px);
        }
        
        .final-title.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .final-line {
            width: 0;
            height: 4px;
            background: linear-gradient(90deg, transparent, white, transparent);
            margin: 0 auto;
            transition: width 2.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .final-line.show {
            width: 300px;
        }
        
        /* 인트로 화면 */
        .intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-width: 100vw;
            min-height: 100vh;
            background: radial-gradient(circle at center, #000428 0%, #000000 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 2s ease-out;
        }
        
        .intro-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .intro-content {
            text-align: center;
            color: white;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 50px 0;
        }
        
        dotlottie-wc {
            display: block;
            border: none !important;
            outline: none;
            background: transparent;
            box-shadow: none;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
            width: 500px;
            height: 500px;
            border-radius: 0;
        }
        
        dotlottie-wc *,
        dotlottie-wc *::before,
        dotlottie-wc *::after {
            border: none !important;
            outline: none;
            box-shadow: none;
            margin: 0;
            padding: 0;
        }
        
        dotlottie-wc canvas,
        dotlottie-wc svg,
        dotlottie-wc iframe {
            border: none !important;
            outline: none;
            box-shadow: none;
            display: block;
            border-radius: 50%;
        }
        
        .intro-title {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 300;
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(30px);
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .intro-title.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .intro-subtitle {
            font-size: clamp(1rem, 3vw, 1.2rem);
            font-weight: 200;
            opacity: 0.7;
            margin-bottom: 3rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
            transition-delay: 0.5s;
        }
        
        .intro-subtitle.show {
            opacity: 0.7;
            transform: translateY(0);
        }
        
        
        .click-hint {
            font-size: 0.9rem;
            opacity: 0.5;
            margin-top: 2rem;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        /* 전체화면 모드 호환성 개선 */
        :fullscreen {
            width: 100vw !important;
            height: 100vh !important;
        }
        
        :-webkit-full-screen {
            width: 100vw !important;
            height: 100vh !important;
        }
        
        :-moz-full-screen {
            width: 100vw !important;
            height: 100vh !important;
        }
        
        :-ms-fullscreen {
            width: 100vw !important;
            height: 100vh !important;
        }
        
    </style>
</head>
<body>
    <!-- 인트로 화면 -->
    <div class="intro-screen" id="intro-screen">
        <div class="intro-content">
            <dotlottie-wc
                src="./resorce/Background looping animation.lottie"
                style="width: 500px;height: 500px"
                autoplay
                loop
            ></dotlottie-wc>
        </div>
    </div>

    <div class="slideshow-container">
        <!-- 슬라이드 1: 뉴트리시아 -->
        <div class="slide active" data-slide="0">
            <img src="./resorce/1..뉴트리시아배경.png" alt="뉴트리시아" class="slide-image">
            <div class="slide-overlay"></div>
            <div class="slide-content">
                <h1 class="slide-title">아기 울음과 함께 시작되는 하루</h1>
                <p class="slide-subtitle">압타밀팀은 오늘도 육아라는 세상과 가장 가까운 곳에 있습니다</p>
            </div>
        </div>

        <!-- 슬라이드 2: 드리미 -->
        <div class="slide" data-slide="1">
            <img src="./resorce/2.드리미배경.webp" alt="드리미" class="slide-image">
            <div class="slide-overlay"></div>
            <div class="slide-content">
                <h1 class="slide-title">부스럭 소리를 줄이는 기술</h1>
                <p class="slide-subtitle">드리미팀은 내일의 청소가 오늘보다 조금 더 편하길 바라며 움직입니다</p>
            </div>
        </div>

        <!-- 슬라이드 3: 브라이튼 -->
        <div class="slide" data-slide="2">
            <img src="./resorce/3.브라이튼배경.jpg" alt="브라이튼" class="slide-image">
            <div class="slide-overlay"></div>
            <div class="slide-content">
                <h1 class="slide-title">더 멀리, 더 밝게</h1>
                <p class="slide-subtitle">브라이튼팀은 여행이라는 이름으로 사람들의 미래를 준비합니다</p>
            </div>
        </div>

        <!-- 슬라이드 4: 우리회사 -->
        <div class="slide" data-slide="3">
            <img src="./resorce/4.우리회사배경.png" alt="우리회사" class="slide-image">
            <div class="slide-overlay"></div>
            <div class="slide-content">
                <h1 class="slide-title">이 모든 팀들이 모이는 곳</h1>
                <p class="slide-subtitle">다른 언어, 다른 기준, 다른 기대. 그래서 우리는 기준을 다시 생각했습니다</p>
            </div>
        </div>

        <!-- 최종 화면 -->
        <div class="final-screen" id="final-screen">
            <div class="particles-container" id="particles-container"></div>
            <div class="final-content">
                <h1 class="final-title">전략기획실</h1>
                <div class="final-line" id="final-line"></div>
            </div>
        </div>
    </div>


    <script>
        // 우주 파티클 효과 클래스
        class SpaceParticleSystem {
            constructor(container) {
                this.container = container;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.starParticles = null;
                this.nebulaParticles = null;
                this.backgroundNebula = null;
                this.animationId = null;
                this.isActive = false;
                this.time = 0;
            }
            
            init() {
                // Three.js 씬 생성
                this.scene = new THREE.Scene();
                
                // 카메라 설정
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.z = 5;
                
                // 렌더러 설정
                this.renderer = new THREE.WebGLRenderer({ 
                    alpha: true, 
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                this.container.appendChild(this.renderer.domElement);
                
                // 우주 요소들 생성
                this.createBackgroundNebula();
                this.createStarField();
                this.createNebulaParticles();
                
                // 윈도우 리사이즈 이벤트
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            // 배경 성운 생성 (회전하는 배경)
            createBackgroundNebula() {
                const geometry = new THREE.PlaneGeometry(20, 20);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec2 resolution;
                        varying vec2 vUv;
                        
                        void main() {
                            vec2 uv = vUv - 0.5;
                            uv.x *= resolution.x / resolution.y;
                            
                            // 회전하는 성운 패턴
                            float angle = time * 0.1;
                            float cos_a = cos(angle);
                            float sin_a = sin(angle);
                            vec2 rotated_uv = vec2(
                                uv.x * cos_a - uv.y * sin_a,
                                uv.x * sin_a + uv.y * cos_a
                            );
                            
                            // 성운의 색상과 패턴
                            float noise1 = sin(rotated_uv.x * 3.0 + time * 0.5) * cos(rotated_uv.y * 2.0 + time * 0.3);
                            float noise2 = sin(rotated_uv.x * 5.0 - time * 0.2) * cos(rotated_uv.y * 4.0 - time * 0.4);
                            
                            // 우주 색상 (보라, 파랑, 핑크)
                            vec3 color1 = vec3(0.3, 0.1, 0.8); // 보라
                            vec3 color2 = vec3(0.1, 0.3, 0.9); // 파랑
                            vec3 color3 = vec3(0.8, 0.2, 0.6); // 핑크
                            
                            float mix1 = (noise1 + 1.0) * 0.5;
                            float mix2 = (noise2 + 1.0) * 0.5;
                            
                            vec3 finalColor = mix(color1, color2, mix1);
                            finalColor = mix(finalColor, color3, mix2 * 0.3);
                            
                            // 거리에 따른 페이드
                            float dist = length(uv);
                            float alpha = (1.0 - smoothstep(0.0, 1.5, dist)) * 0.3;
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.backgroundNebula = new THREE.Mesh(geometry, material);
                this.backgroundNebula.position.z = -10;
                this.scene.add(this.backgroundNebula);
            }
            
            // 별 필드 생성
            createStarField() {
                const starCount = 500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(starCount * 3);
                const colors = new Float32Array(starCount * 3);
                const sizes = new Float32Array(starCount);
                
                for (let i = 0; i < starCount; i++) {
                    const i3 = i * 3;
                    
                    // 별 위치 (구형으로 분산)
                    const radius = Math.random() * 25 + 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    // 별 크기 (다양한 크기)
                    sizes[i] = Math.random() * 0.3 + 0.1;
                    
                    // 별 색상 (흰색, 파란색, 노란색)
                    const color = new THREE.Color();
                    const colorType = Math.random();
                    if (colorType < 0.7) {
                        // 흰색 별
                        const brightness = Math.random() * 0.3 + 0.7;
                        color.setHSL(0, 0, brightness);
                    } else if (colorType < 0.9) {
                        // 파란색 별
                        color.setHSL(0.6, 0.8, 0.8);
                    } else {
                        // 노란색 별
                        color.setHSL(0.15, 0.8, 0.9);
                    }
                    
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // 별 텍스처 생성
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                // 별 모양 그라데이션
                const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                context.fillStyle = gradient;
                context.beginPath();
                context.arc(32, 32, 32, 0, Math.PI * 2);
                context.fill();
                
                const texture = new THREE.CanvasTexture(canvas);
                
                const material = new THREE.PointsMaterial({
                    map: texture,
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.starParticles = new THREE.Points(geometry, material);
                this.scene.add(this.starParticles);
            }
            
            // 성운 파티클 생성
            createNebulaParticles() {
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const velocities = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // 위치 설정 (구형으로 분산)
                    const radius = Math.random() * 15 + 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    // 속도 설정 (부드러운 움직임)
                    velocities[i3] = (Math.random() - 0.5) * 0.01;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
                    
                    // 크기 설정 (성운 파티클은 더 크고 부드러움)
                    sizes[i] = Math.random() * 0.4 + 0.2;
                    
                    // 성운 색상 (보라, 파랑, 핑크)
                    const color = new THREE.Color();
                    const colorType = Math.random();
                    if (colorType < 0.4) {
                        // 보라색
                        color.setHSL(0.8, 0.6, 0.7);
                    } else if (colorType < 0.7) {
                        // 파란색
                        color.setHSL(0.6, 0.8, 0.8);
                    } else {
                        // 핑크색
                        color.setHSL(0.9, 0.7, 0.8);
                    }
                    
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // 속도를 geometry에 저장
                this.velocities = velocities;
                
                // 성운 텍스처 생성 (더 부드러운 그라데이션)
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
                gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                context.fillStyle = gradient;
                context.beginPath();
                context.arc(32, 32, 32, 0, Math.PI * 2);
                context.fill();
                
                const texture = new THREE.CanvasTexture(canvas);
                
                const material = new THREE.PointsMaterial({
                    map: texture,
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.nebulaParticles = new THREE.Points(geometry, material);
                this.scene.add(this.nebulaParticles);
            }
            
            animate() {
                if (!this.isActive) return;
                
                this.animationId = requestAnimationFrame(() => this.animate());
                
                this.time += 0.016; // 약 60fps
                
                // 배경 성운 회전 및 시간 업데이트
                if (this.backgroundNebula) {
                    this.backgroundNebula.material.uniforms.time.value = this.time;
                    this.backgroundNebula.rotation.z += 0.001;
                }
                
                // 별 필드 회전
                if (this.starParticles) {
                    this.starParticles.rotation.x += 0.0003;
                    this.starParticles.rotation.y += 0.0005;
                }
                
                // 성운 파티클 애니메이션
                if (this.nebulaParticles && this.velocities) {
                    // 전체 회전
                    this.nebulaParticles.rotation.x += 0.0008;
                    this.nebulaParticles.rotation.y += 0.0012;
                    
                    // 파티클 위치 업데이트
                    const positions = this.nebulaParticles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        const index = i / 3;
                        
                        // 기본 속도 적용
                        positions[i] += this.velocities[i];
                        positions[i + 1] += this.velocities[i + 1];
                        positions[i + 2] += this.velocities[i + 2];
                        
                        // 우주적인 파도 효과
                        positions[i + 1] += Math.sin(this.time * 0.3 + index * 0.1) * 0.008;
                        positions[i] += Math.cos(this.time * 0.2 + index * 0.15) * 0.005;
                        positions[i + 2] += Math.sin(this.time * 0.4 + index * 0.08) * 0.003;
                        
                        // 경계 체크 (구형 범위 내에서)
                        const distance = Math.sqrt(positions[i]**2 + positions[i+1]**2 + positions[i+2]**2);
                        if (distance > 20) {
                            // 중심으로 다시 끌어당기기
                            positions[i] *= 0.98;
                            positions[i + 1] *= 0.98;
                            positions[i + 2] *= 0.98;
                        }
                    }
                    
                    this.nebulaParticles.geometry.attributes.position.needsUpdate = true;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            start() {
                if (!this.isActive) {
                    this.isActive = true;
                    this.animate();
                }
            }
            
            stop() {
                this.isActive = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
            
            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
                
                // 전체화면 모드에서도 올바른 크기 보장
                this.renderer.domElement.style.width = '100%';
                this.renderer.domElement.style.height = '100%';
            }
            
            destroy() {
                this.stop();
                if (this.renderer && this.renderer.domElement) {
                    this.container.removeChild(this.renderer.domElement);
                }
                if (this.renderer) {
                    this.renderer.dispose();
                }
            }
        }

        class Slideshow {
            constructor() {
                this.currentSlide = 0;
                this.isTransitioning = false;
                this.slides = document.querySelectorAll('.slide');
                this.finalScreen = document.getElementById('final-screen');
                this.finalLine = document.getElementById('final-line');
                this.introScreen = document.getElementById('intro-screen');
                this.slideDuration = 4000; // 4초
                this.clickCount = 0;
                this.requiredClicks = 2;
                this.particleSystem = null;
                this.currentState = 'intro'; // 현재 상태: 'intro', 'slideshow', 'final'
                
                
                this.init();
            }
            
            init() {
                this.setupIntro();
            }
            
            setupIntro() {
                // 엔터 키 이벤트 리스너 - 인트로 상태에서만 작동
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && this.currentState === 'intro') {
                        this.handleIntroClick();
                    }
                });
            }
            
            handleIntroClick() {
                this.clickCount++;
                
                if (this.clickCount >= this.requiredClicks) {
                    this.startSlideshow();
                }
            }
            
            startSlideshow() {
                // 상태를 slideshow로 변경
                this.currentState = 'slideshow';
                
                // 인트로 화면 숨기기
                this.introScreen.classList.add('hidden');
                
                
                // 슬라이드쇼 시작
                setTimeout(() => {
                    this.beginSlideshow();
                }, 2000);
            }
            
            beginSlideshow() {
                this.startSlideshowAnimation();
            }
            
            
            async showSlide(index) {
                if (this.isTransitioning) return;
                this.isTransitioning = true;
                
                // 모든 슬라이드 숨기기
                this.slides.forEach((slide, i) => {
                    slide.classList.remove('active');
                    if (i === index) {
                        slide.classList.add('active');
                    }
                });
                
                // 현재 슬라이드의 텍스트 애니메이션
                const currentSlide = this.slides[index];
                const title = currentSlide.querySelector('.slide-title');
                const subtitle = currentSlide.querySelector('.slide-subtitle');
                
                // 텍스트 애니메이션 리셋
                title.classList.remove('show');
                subtitle.classList.remove('show');
                
                // 텍스트 애니메이션 시작
                await this.animateText(title, subtitle);
                
                this.isTransitioning = false;
            }
            
            async animateText(title, subtitle) {
                // 제목 애니메이션
                await new Promise(resolve => {
                    setTimeout(() => {
                        title.classList.add('show');
                        resolve();
                    }, 500);
                });
                
                // 부제목 애니메이션
                await new Promise(resolve => {
                    setTimeout(() => {
                        subtitle.classList.add('show');
                        resolve();
                    }, 300);
                });
            }
            
            async nextSlide() {
                if (this.currentSlide < this.slides.length - 1) {
                    this.currentSlide++;
                    await this.showSlide(this.currentSlide);
                    
                    // 슬라이드 지속 시간 대기
                    await new Promise(resolve => {
                        setTimeout(resolve, this.slideDuration);
                    });
                    
                    // 다음 슬라이드로
                    this.nextSlide();
                } else {
                    // 마지막 슬라이드 후 최종 화면 표시
                    console.log('마지막 슬라이드 완료, 최종 화면 표시 시작');
                    
                    
                    await new Promise(resolve => {
                        setTimeout(resolve, this.slideDuration);
                    });
                    
                    await this.showFinalScreen();
                }
            }
            
            async showFinalScreen() {
                console.log('최종 화면 표시 시작');
                
                // 상태를 final로 변경
                this.currentState = 'final';
                
                // 최종 화면 표시
                this.finalScreen.classList.add('show');
                
                // 파티클 시스템 초기화 및 시작
                this.initParticleSystem();
                
                
                // 제목 애니메이션
                await new Promise(resolve => {
                    setTimeout(() => {
                        const finalTitle = this.finalScreen.querySelector('.final-title');
                        if (finalTitle) {
                            finalTitle.classList.add('show');
                            console.log('최종 제목 애니메이션 시작');
                        }
                        resolve();
                    }, 1000);
                });
                
                // 라인 애니메이션
                await new Promise(resolve => {
                    setTimeout(() => {
                        if (this.finalLine) {
                            this.finalLine.classList.add('show');
                            console.log('라인 애니메이션 시작');
                        }
                        resolve();
                    }, 2000);
                });
                
                // 엔터 키 대기
                this.setupFinalControl();
            }
            
            
            initParticleSystem() {
                const particlesContainer = document.getElementById('particles-container');
                if (particlesContainer && typeof THREE !== 'undefined') {
                    this.particleSystem = new SpaceParticleSystem(particlesContainer);
                    this.particleSystem.init();
                    this.particleSystem.start();
                    console.log('우주 파티클 시스템 시작됨');
                } else {
                    console.warn('Three.js가 로드되지 않았거나 파티클 컨테이너를 찾을 수 없습니다.');
                }
            }
            
            setupFinalControl() {
                let enterCount = 0; // 엔터 키 누른 횟수 추적
                
                // 엔터 키 이벤트 리스너 추가 - final 상태에서만 작동
                const handleKeyPress = (e) => {
                    if (e.key === 'Enter' && this.currentState === 'final') {
                        enterCount++;
                        
                        // 엔터 키를 2번 눌러야 presentation.html로 이동
                        if (enterCount >= 2) {
                            // 파티클 시스템 정리
                            if (this.particleSystem) {
                                this.particleSystem.destroy();
                            }
                            document.removeEventListener('keydown', handleKeyPress);
                            // presentation.html로 이동
                            window.location.href = 'presentation.html';
                        }
                    }
                };
                document.addEventListener('keydown', handleKeyPress);
            }
            
            async startSlideshowAnimation() {
                // 첫 번째 슬라이드 텍스트 애니메이션
                const firstSlide = this.slides[0];
                const title = firstSlide.querySelector('.slide-title');
                const subtitle = firstSlide.querySelector('.slide-subtitle');
                
                await this.animateText(title, subtitle);
                
                // 첫 번째 슬라이드 지속 시간 대기
                await new Promise(resolve => {
                    setTimeout(resolve, this.slideDuration);
                });
                
                // 슬라이드쇼 시작
                this.nextSlide();
            }
        }
        
        // 슬라이드쇼 시작
        new Slideshow();
    </script>
</body>
</html>